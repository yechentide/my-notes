# 構造体

## 構造体とは

構造体は複数の属性を持ったデータを型として定義する  
クラスと列挙型と同じく、プロパティやメソッド、  
さらにイニシャライザ、サブスクリプトを作れる

## 構造体の定義

```swift
// それぞれの定義はオプションで、個数や順序は自由
struct 名前 {
    変数/定数定義
    イニシャライザ定義
    メソッド定義
    その他の定義        // 型定義、プロパティ定義、添字付け定義など
}
```
- 構造体の中に、他の構造体を定義できる。外部では`構造体A.構造体B`の形で使える
- 構造体のネストができる

## イニシャライザ

```swift
struct 名前 {
    init(仮引数:型){
        // ....
    }
}
```
- オーバーロードできる
- ==全ての初期値を設定完了後==、イニシャライザ内部でも==インスタンスメソッド==を呼び出せる
- イニシャライザを１つも定義していない場合、２つのイニシャライザが使える
    1. `既定イニシャライザ`：実引数を使わずに、デフォルト値のままで呼び出すイニシャライザ。`型()`
    2. `全項目イニシャライザ`：すべてのプロパティを、宣言順にイニシャライザの引数ラベルとして使われる。初期値がある者は省略可能

## メソッド

- メソッドは同じインスタンスのプロパティ＆メソッドをアクセスできる
- インスタンスの内容を変更するメソッドは、先頭に`mutating`をつける  
    定数に代入されるインスタンスから、`mutating`をつけたメソッドの呼び出しが禁止される
    ```swift
    struct Name {
        var num: Int
        mutating func setNum(n:Int){
            // ...
        }
    }
    ```
- 宣言の前に`static`をつけると、静的メソッドとなる  
    構造体の定義の中であれば、`Self.静的メンバ`でも、他の静的メンバをアクセスできる

### 構造体内部で演算子定義

構造体を引数とする演算子は、構造体内部で定義することが普通である  
その時、`static`キーワードをつける

## プロパティについて

### プロパティ概要

- デフォルト値を指定できる。全てのプロパティにデフォルト値を与える場合、引数なしのイニシャライザを使える。
- プロパティにアクセスする時、`インスタンス名.プロパティ`の形で使う
- 定数プロパティの場合、初期値を指定するか、イニシャライザで初期値を設定する必要がある
- 他の構造体をプロパティにできる
- 宣言の前に`static`をつけると、静的プロパティとなる  
    構造体の定義の中であれば、`Self.静的メンバ`でも、他の静的メンバをアクセスできる

### プロパティの種類

- 格納型プロパティ：値を保存するためのもの
- 計算型プロパティ：値の取得＆更新をするためのもの ( getter & setter )
    1. 値の参照＆更新の両方ができるもの
    2. 値の参照のみができるもの

### 計算型プロパティ

```swift
struct Name {
    var 変数名: 型 {
        get {
            // ...
        }
        set(仮引数) {
            // ...
        }
    }
}
```
- get節のみの場合、`get`と`{}`を省略できる： `var 変数名: 型 { 式など }`
- get節内部で格納型プロパティを変更したい場合、`mutating`をつける
- set節は省略可能で、get節との順番が逆でも良い
- setの仮引数がなくても良い
- set節は、新しい値を受け取る仮引数を使う。それを省略したらデフォルトの`newValue`という名前の引数を使う
- set節内部で構造体自体の持つ値を変更しない場合、`nonmutating`をつける  
    こうすれば、定数に代入されるインスタンスからも呼び出せる

### プロパティオブザーバ

格納型プロパティの値が更新される時に処理を行うこと。  
値が更新される前後の２種るがあり、全て省略・１つだけ記述・全て記述は可能 (順番も関係ない)
```swift
struct Name {
    var 変数名: 型 = 初期値 {
        willSet(仮引数) {
            // 更新される直前に
        }
        didSet(仮引数) {
            // 更新される直後に
        }
    }
}
```
- 初期値は省略可能
- willSetの時の仮引数は、与える新しい値のこと。省略すると`newValue`を使う
- didSetの時の仮引数は、格納していた値のこと。省略すると`oldValue`を使う
- イニシャライザで初期設定する時に、プロパティオブザーバは呼び出されない

## 添字付け(subscript)

複数個のプロパティがある時、配列のようにアクセスできるようにする機能  
subscriptを定義することで、`name[1]`や`name["a",2]`のように構造体の要素をアクセスできる  
可変長引数も使えるし、オーバーロードもできる  
読み書きができるものと、読み出しだけができるものを定義できる
```swift
struct 名前 {
    subscript(引数:型) -> 戻り値の型 {
        get {
            // ...
        }
        set(仮引数) {
            // ...
        }
    }
}
```
- get節のみの場合、`get`と`{}`を省略できる
- setの仮引数がなくても良い
- set節は省略可能で、get節との順番が逆でも良い
- set節は、新しい値を受け取る仮引数を使う。それを省略したらデフォルトの`newValue`という名前の引数を使う
- 添字付けにも`static`をつけられる。`構造体名[index]`でアクセスできる
- `self[添字]`で自身の添字付け機能にアクセスできる

### インライン展開

小規模かつ頻繁に使われる関数に`@inlinable`をつける  
関数のほか、メソッド、計算型プロパティ、添字付け、イニシャライザに対しても使える

## 構造体でプロトコルを採用

```swift
protocol Monster {
    var monsterName:String {get}
    var hp:Int {get set}
    mutating func updateHP(pt:Int)
}

struct Pokemon: Monster {
    // プロトコルではread onlyなので、setを制限
    private(set) var monsterName:String
    var hp:Int
    mutating func updateHP(pt:Int){
        hp += pt
    }
}

var pikachu = Pokemon(monsterName:"ピカチュー", hp:200)
pikachu.updateHP(30)            // hpが230に
```
