# 並行処理

## Goroutine

`goroutine(ゴルーチン)`とは、Go言語のプログラムで並行に実行されるもののこと

### 起動の仕方

関数 (またはメソッド) の==呼び出しの前に== `go` を付けると、異なる `goroutine` で関数を実行することができる
```go
go 関数名(引数, ...)
```

### 終了条件

- 関数の処理が終わる。
- `return`で抜ける。
- `runtime.Goexit()` を実行する
- プログラム終了

### 存在するgoroutineの数の取得

`runtime.NumGoroutine()`を使用する事で現在起動している`goroutine(ゴルーチン)`の数を知ることできる
```go
import( 
    "fmt"
    "log"
    "runtime"
)

func main() {
    log.Println(runtime.NumGoroutine())
}
```

## Channel

Goroutineの処理が終わる前にプログラムが終了してしまったら困る。  
`channel(チャネル)`は、値の交換および同期という通信機能を兼ね備えてあり、  
2つの計算処理(ゴルーチン)が予期しない状態とならないことを保証してくれる

### チャンネルの生成

チャンネルは参照型のデータ
```go
var 変数 = make(chan 型, バッファの大きさ)
var 変数 = make(chan 型)    // バッファの大きさは省略可能
```

### 使い方

チャネル型の変数を作成し、送信側・受信側ともに、その変数に対して何らかのデータを送受信する  
チャネルオペレータの `<-` を用いる事で値の送受信ができる
```go
ch <- data      //dataをchへ送信する(vをchに書き込む)
arg := <-ch     //chから受信した変数をargへ割り当てる(chの値を読み込む)
```
Goroutineを使った関数内でChannelに送信し、この関数の外部で受信することができる  
受信側では常に、==受信可能なデータが来るまで停止される==  
Channelは、関数の引数として使える！
