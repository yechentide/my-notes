# 配列＆Slices

## 配列の基本

配列は固定サイズのため、Goでは配列を直接使うことが少ない  
添え字は0から始まる  
要素が比較可能であれば、配列も`==`で比較できる  
引数として関数に渡す場合、コピーされる  
配列リテラルは、値を順番に指定したり、インデックスを明示的に与えたり、または両方混在したりできる
```go
// 宣言方法
var 変数名 [長さ]型
var 変数名 [長さ]型 = [大きさ]型{初期値1, 初期値n}
変数名 := [...]型{初期値１, ..., 初期値n}
変数名 := [...]型{99: -1}      // 0~98番目は0, 最後に-1
```

## Slices

可変長配列のようなもの。初期化されていない場合は`nil`になる  
配列の宣言と違って、スライスは `[ ]` の中に大きさを指定しない  
スライスは３つの情報を持っている：
- ポインタ: スライスを通してアクセス可能な、基底配列の最初の要素を指す
- 長さ: スライスの要素数
- 容量: スライスの開始から、基底配列の終わりまでの要素数

==スライスは配列への「参照型」==で値を持つため、  
配列から部分列を取り出して `元配列など[i:j]` でスライスを作成することが可能  
配列と違って、スライスは`==`で比較できない([]byteだけは`bytes.Equal`関数がある)
```go
var 変数名 []型
var 変数名 []型 = []型{初期値1, ..., 初期値n} 
変数名 := 配列[start:end]           //配列(またはスライス)のstartから(end - 1)を取り出してスライスを作成
```
組み込み関数の `make()` を利用することで定義できる  
初期容量を省略した場合は初期個数と同じ容量が確保され
```go
make([]型, len)
make([]型, len, cap)        // make([]T, cap)[:len] と同じ

func main() {
    a := make([]int, 5, 5)
    fmt.Println(a) //=> [0 0 0 0 0]
}
```

### スライス操作

スライス操作は元の配列への参照を作っているので、変更などが元となる配列に影響してしまう
- `Slice[start:end]`：start から end - 1 まで
- `Slice[start:]`：start から最後尾まで
- `Slice[:end]`：先頭から end - 1 まで
- `Slice[:]`：先頭から最後尾まで

### 要素の追加

`newSlice := append(slice, "Ruby")`の形で追加する  
容量を超えると、倍の容量のメモリが別に確保され、既存データがコピーされる

### スライス同士の代入

型が同じであれば代入できる。同じアドレスを利用することになる(影響し合うことに)

### スライスの拡張

`s[:newLength]`のように、`len < newLength < cap`となる`newLength`でスライスを拡張できる  
`newLength`が`cap`を超えるとパニックになる

### その他

- `len(スライス)`：要素の数
- `cap(スライス)`：スライスの最初の要素から数えて、元となる配列の要素数
