# SwiftUIについて

## SwiftUIで解決する問題点

SwiftUIの宣言型Swift構文やプレビューにより、従来の開発手法の問題点を解決する:
1. StoryboardやXibのXMLは編集困難
    - チーム開発で同時編集ができない
    - XMLの差分を見ても変更点の把握が困難
2. StoryboardやXibとソースコードが別に存在
    - UIとコードをそれぞれ把握する必要がある
    - StoryboardやXibとコードの紐付けが切れるとエラーになる
3. 端末のスクリーンサイズの多様化
    - AutoLayoutの制約(Constraints)の難しさ

## SwiftUIにおけるレイアウト

従来の開発手法では、制約(Constraints)をベースとしたAuto Layoutという機能を使っていた。  
SwiftUIでは制約ベースのUI設計ではなく、より柔軟なスタックレイアウトを使用している。  
画面に複数のボックス要素を作り、それらをレイアウトに沿って敷き詰めてデザインを作り上げる方式である。

## SwiftUIにおける状態の監視＆ビューの更新

従来のイベント駆動型プログラミングでは、
「変数が変更→ビューを更新」「ビューが変更→変数を上書き」のような双方向での同期処理が難しい場合がある。  
SwiftUIではシステム側で状態の監視を行い、ビューの状態と変数の同期を自動的に行うことができる。  
またビューの更新処理も、プログラマ側で逐一記述する必要がなくなり、  
SwiftUIでは、あらかじめ「どの状態で何を表示すべきか」を指定しておけば、関連するビューを全て自動で更新してくれる。  
このSwiftUIにおける、UIに影響を与える値の監視イベントに利用されているのは、Swift5.1で導入された機能:
1. 不透明型(Opaque Return Type)
    `var body: some View`の`some`
2. 暗黙のreturn
    計算型プロパティ`body`内の`get`キーワードの省略
3. プロパティラッパー(Property Wrapper)
    `@State`など
4. 関数ビルダー(Function builders)
    `VStack`などの中に、ビューの定義を並べて記述できる

## SwiftUIのビュー

SwiftUIでは、`View`プロトコルを採用したビューを組み合わせて、最終的に画面に表示するためのカスタムビューを作成する。

## Bindingオブジェクトを取得

プロパティラッパとして定義された構造体は、`projectedValue`という計算型プロパティを持っている。  
`State`にも、戻り値がBinding型の`projectedValue`プロパティがある。  
プロパティラッパでラップした変数の場合、`$`を先頭につけると、`projectedValue`プロパティを呼び出した結果を返す。
