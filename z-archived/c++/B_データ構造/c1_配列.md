# 配列

## 固定長配列

### １次元の

```c++
型 配列名[要素数];
型 配列名[要素数] = {};     // 全て0で初期化
型 配列名[要素数] = {値, 値, 値, ...};
型 配列名[] = {値, 値, 値, ...};
```

### 2次元の

```c++
型 配列名[要素数][要素数];
型 配列名[要素数][要素数] = {   {...},{...}   };
型 配列名[][要素数] = {   {...},{...}   };
```

## 動的配列std::vector

`#include <vector>`

### 生成

```c++
std::vector<型> 変数名;            // 空のvectorを生成
std::vector<型> 変数名{数};        // "数"個の空要素を生成
std::vector<型> 変数名{数, 値};    // "数"個の値で生成

// stringのイテレーターによるvector生成
std::string str = "apple";
std::vector<char> cv{str.begin(), str.end()};
// ポインタによるvector生成
char fruit[] = "apple";
std::vector<char> cv{fruit, fruit+5};

// std::initializer_listによるvector生成
std::vector<char> iv = {1, 2, 3, 4, 5, 6};
std::vector 変数名 = {値};      // 型推論

// コピーによるvector生成
std::vector v2 = v1;
```

### 代入

```c++
v2 = v1;
v2 = {1, 2, 3};
```

### アクセス

```c++
// 添字演算子でアクセス
v[3];
// イテレーターでアクセス
for(auto iter=v.begin(); iter!=v.end(); iter++){ cout << *iter; }
for(auto iter=v.rbegin(); iter!=v.rend(); iter++){ cout << *iter; }     // 逆順
```

### 挿入

```c++
// 与えられた要素のコピーを挿入
insert(挿入位置を表すイテレーター, 挿入する数値);
insert(挿入位置を表すイテレーター, 数値の個数, 挿入する数値);
insert(挿入位置を表すイテレーター, 開始イテレーター, 終了イテレーター);

// 与えられた要素をコンストラクタとして、コピーを作らずに直接生成
emplace(挿入位置を表すイテレーター, コンストラクタ引数);

// 末尾へ挿入
push_back(値);
emplace_back(コンストラクタ引数);
```

### 削除

```c++
erase(位置を表すイテレーター);
erase(開始イテレーター, 終了イテレーター);

clear();        // 要素を全て削除

pop_back(); // 末尾要素の削除
```

### その他のメンバ関数

* `size()`：要素数を返す
* `begin()`：先頭のイテレーターを返す
* `end()`：末尾のイテレーターを返す
* `resize()`：任意のタイミングで配列の長さを変更。
    第１引数は配列長、増えた部分は第２引数で初期化する(省略可)
* `assign()`：要素の差し替え
   1. `assign(開始イテレーター, 終了イテレーター)`
   2. `assign(数値, 個数)`
   3. `assign({値, 値, 値})`

### 注意

ポインタを格納するvectorを破棄する時に、手動でポインタを`delete[]`する必要がある
要素をの挿入・削除による要素の移動が起こる時、要素を指すイテレーターが無効になる場合がある
