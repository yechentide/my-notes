# アドレス＆ポインタ

## アドレス

データがメモリ上の場所を表す

### 変数のアドレス

```c++
&変数名
```

### 配列のアドレス

```c++
配列名      // 配列の先頭要素のアドレス
&配列名[0]  // 配列の先頭要素のアドレス
```

配列名=配列の先頭要素のポインタ。他のアドレスの代入はできない

## ポインタ

アドレスを格納する特殊な変数のこと

### 宣言

```c++
型* ポインタ名;

型 *ポインタ名;
型 *ポインタ名1, *ポインタ名2;
```

### 使い方

```c++
ポインタ名      // アドレス
*ポインタ名     // そのアドレスにある値
```

定数のアドレスを普通のポインタに代入できない
定数も変数もそのアドレスをconstポインタに代入できる
constポインタはアドレスで値操作ができない
constポインタは後から別のアドレスを代入できる

```c++
const 型 *ポインタ名;
型 const *ポインタ名;
```

`const`を`*`の右辺に書くと、普通のポインタとなり、アドレスで値操作ができるが、後からアドレスを代入できない

```c++
型* const ポインタ名 = アドレス;
```

### ポインタ演算

p, p1, p2はポインタ

| 演算子 |   例    |                    説明                     |
| :----: | :-----: | :-----------------------------------------: |
|  `+`   |  `p+1`  | pが指している要素の次の要素のアドレスを得る |
|  `-`   |  `p-1`  | pが指している要素の前の要素のアドレスを得る |
|        | `p1-p2` |          p1とp2の間の要素数を得る           |
|  `++`  |  `p++`  |                 `p+1`と同じ                 |
|  `--`  |  `p--`  |                 `p-1`と同じ                 |

また、ポインタに`[ ]`演算子を使って、配列のように表記できる

`p[2]`  =  `p+2`

### Nullポインタ

どの変数も指さないポインタ。無効なアドレスなので使い道がない

```c++
int* pt = 0
int* pt = nullptr
```

いつもNullポインタかどうかを確認するのがベスト

```c++
if(ptr!=nullptr){}
```

### ポインタのポインタ

```c++
int num = 100;
int *p = &num;
int **pp = &p;

cout << " pのアドレスは" << p << "で、値は" << *p << "です\n";
cout << "ppのアドレスは" << pp << "で、値は" << *pp << "です\n";

cout << "ポインタpp経由でnumをアクセスしてみる\n";
cout << "**pp=" << **pp;
```
