# 関数＆ラムダ式

## 関数

### 定義場所

1. 呼び出される場所の前
2. プロトタイプ宣言で、先に関数の名前＆引数の数をコンパイラに知らせておく

### 関数定義

```c++
void 関数名(){
    // ...
}
戻り値の型 関数名(型 仮引数名, 型 仮引数名, ...){
    // ...
    return 戻り値;
}
```

デフォルト引数を定義できる
デフォルト引数は、**右から順に**設定しなければならない

```c++
void 関数名(型 引数名=デフォルト値, ...){   }
```

### 実引数＆仮引数

関数定義内の引数を仮引数、呼び出し元で渡す引数を実引数という。
引数を渡す際、普通は参照渡しではなく、値だけ渡している
なので、関数内で実引数を変えたい時、ポインタや参照を使うべき
ただし、ポインタ＆参照を使っても、実引数を変えたくない時がある。
そんな時に、`const`をつける

```c++
void func1(const int *pX);
void func2(const int &X);
```

### プロトタイプ宣言

```c++
戻り値の型 関数名(型 仮引数名, 型 仮引数名, ...);
```

### inline関数

関数を使うと、処理はより時間がかかる。
何度も呼び出されるような小さな関数の場合、この時間を無視できない
こんなとき、inline関数を使う

```c++
inline 戻り値の型 関数名(型 仮引数名, 型 仮引数名, ...){
    // ...
    return 戻り値;
}
```

コンパイラは、関数の呼び出し元に、関数の中身となるコードを埋め込む
注意：コンパイラは**短い処理だけ**をinline関数として埋め込む

### 関数のオーバーロード

引数の型や数が異なっていれば、同じ名前を持つ関数を複数定義できる

## ラムダ式

### 基本形

ほとんどの場合、関数の実引数 or `auto`で宣言した変数に代入して使う

```c++
[](型 仮引数名, 型 仮引数名, ...) -> 戻り値の型 {
    // ...
}

// 「-> 戻り値の型」を省略可能
auto show = [](string s) -> void {
    cout << s << endl;
};
show("Hello world!");
```

### 変数キャプチャ

普通の関数もラムダ式も、引数以外の関数外変数を使えない。
しかし、ラムダ式の変数キャプチャ機能を使えば、
ラムダ式の外側で宣言された変数のコピーを格納し、内部で使えるようになる
引数の受け取るのと違って、ラムダ式を呼び出す際に渡す必要がない
先頭に`=`を記述すれば、内部で使っている変数を、コンパイラが自動的にキャプチャする

```c++
[変数, ...](引数) -> 戻り値の型 {
    // ...
}
[=, 変数, ...](引数) -> 戻り値の型 {
    // ...
}

int main(){
    int a = 0;
    auto lamda = [a](){   cout << a << endl;   };
    lamda();    // 0
    a = 42;
    lamda();    // 0
}
```

コピーとしてキャプチャした変数は暗黙的に`const`となる
変更する必要がある場合、`mutable -> 戻り値の型`と指定すれば良い
しかしmutableは全てのキャプチャした変数に影響するので、注意すべきだ
これを使う機会がほとんどないかもしれない

### 参照を取得するキャプチャ

```c++
[&変数, ...](引数) -> 戻り値の型 {
    // ...
}
[&, &変数, ...](引数) -> 戻り値の型 {
    // ...
}
