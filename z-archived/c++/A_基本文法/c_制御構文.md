# 制御構文

## ループ

### for

```c++
for(初期化; 条件判定; 変化){
    // ...
}
```

```c++
for(型 i : 配列など){
    // ...
}
```

### while

```c++
while(条件){
    // ...
}
```

do-while文は、最低でも一回は処理を実行する

```c++
do{
    // ...
}while(条件)
```

## 条件分岐

### if

```c++
if(条件式){
    // ...
}else if(条件式){
    // ...
}else{
    // ...
}
```

#### 初期化構文付きif(C++17から)

```c++
if(型 変数=値; 条件式){
    // ...
}else if(条件式){
    // ...
}else{
    // ...
}
```

### switch

```c++
switch(式){
    case 値1:
        // ...
        break;
    case 値2:
    case 値3:
        // ...
        break;
    default:
        // ...
        break;
}
```

#### 初期化構文付きswitch(C++17から)

これを使う機会はほとんどない

```c++
switch(型 変数=値; 式){ ... }
```

## 例外処理

### throw/try/catch

```c++
try{
    // ...
}catch(例外の型 変数名){
    // ...
}catch(例外の型 変数名){
    // ...
}

throw 例外;
```

### 強制終了

投げられた例外を誰も捕まえることができなければ、デフォルトで`std::terminate()`関数が呼ばれ、プログラムを強制終了することになる。

### 全てを捕まえるcatch節

catch節の最後に１つだけ記述できる

```c++
catch(...){
   // ...
}
```

### 例外の再送出

例外が投げられると、処理が一気にcatch節にくるため、場合によってメモリリークが起きるかもしれない。
何も例外オブジェクトを指定しないthrow文で、catch節が捕まえた例外をもう１回投げることができる。

```c++
catch(...){ // ...じゃなくても良い
    throw;
}
```

### noexcept指定

関数にnoexcept指定すると、その関数から絶対に例外が投げられないことを宣言できる。

```c++
戻り値の型 関数名(引数) noexcept;
戻り値の型 関数名(引数) noexcept {   }
```

### new演算子の例外処理

### 標準例外

## その他

### break

`break`：　処理の流れを強制的に終了し、そのブロックから抜ける

### continue

`continue`：　ブロック内の処理を飛ばし、ブロックの先頭に戻って次の処理を続ける

### goto

```c++
ラベル:

goto ラベル;
```

**同じ関数内**にあるるラベルの場所に処理を強制的に移る
**同じ関数内**であれば、ラベルの場所はどこでも良い
