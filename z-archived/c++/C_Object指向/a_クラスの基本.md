# クラスの基本

## クラス宣言

アクセス指定子を省略したら、全て`private`となる

```c++
class クラス名 {
    アクセス指定子:
    変数宣言;
    メンバ関数宣言;
};
```

メンバ関数の定義：
クラス宣言の中に定義するメンバ関数は、inline関数となる

```c++
戻り値の型 クラス名::メンバ関数名(型 仮引数名, 型 仮引数名, ...){
   // ...
   return 戻り値;
}
```

例：

```c++
class Car {
    public:
    int num;
    double gas;
    void show();
};
void Car::show(){
    cout << "車のナンバーは" << num << "です\n"
}
```

## 使い方

```c++
Car car1;
car1.num = 1234;
car1.gas = 20.5;
car1.show();
```

オブジェクトを動的に生成する

```c++
Car *pCar = new Car;
pCar->num = 1234;
pCar->gas = 20.5;
delete pCar;
```

## クラスのポインタ＆参照

```c++
Car *pCar = &car1;
cout << pCar->num;
```

```c++
Car &rCar = car1;
cout << rCar.num;
```

## メンバ変数のデフォルトの初期値 (NSDMI)

メンバ変数のデフォルトの初期値を指定する

```c++
class クラス名 {
    型 変数 = 初期値;
    型 変数 = {初期値};
    型 変数(初期値);
    型 変数{初期値}
}
```

## constメンバ関数＆mutable

コンパイラから見て、メンバ関数は全てメンバ変数を変えるかもしれない。
なのでconstインスタンスにgetterを使ってもエラーとなる。
その時、そのメンバ関数の宣言と定義のところに`const`をつければ良い
関数名＆引数などが全く同じでも、constメンバ関数と非constメンバ関数が共存できる

```c++
class クラス名 {
    int getter();
    int getter() const;
};
int クラス名::getter() {}       // 非constインスタンスで呼び出される
int クラス名::getter() const {} // constインスタンスでのみ呼び出される
```

メンバ変数の前に`mutable`をつけると、constメンバ関数からでも変更できるようになる

```c++
class クラス名 {
    mutable int age;
};
```

**`mutable`を使ったconstメンバ関数からの書き換えは、以下のような十分な理由がある場合にのみに留めるべきだ**

1. 内部の処理でしか使われない場合
2. それによって安全で一貫した操作ができる場合
3. それによって著しくプログラムの速度が向上できる場合
4. など

## 静的メンバ

`static`をつける
privateなstaticメンバ変数は、そのクラスからしかアクセスできない

```c++
class クラス名 {
public:
    static 型 変数名;
    static 戻り値の型 関数名(引数);
};
型 クラス名::変数名 = 値;
戻り値の型 クラス名::関数名(引数){}

クラス名::変数名;
クラス名::関数名();
```
