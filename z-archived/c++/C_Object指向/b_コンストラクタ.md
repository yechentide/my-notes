# コンストラクタ＆デストラクタ

## コンストラクタ

デフォルト引数も使えるぞ〜

```c++
class クラス名 {
public:
    クラス名(型 仮引数名, 型 仮引数名, ...);
};

クラス名::クラス名(型 仮引数名, 型 仮引数名, ...) : メンバ変数(初期値), .... {
    // ...
}
```

`: メンバ変数(初期値), ....`をメンバ初期化リストという。コンストラクタ本体より先に処理される
メンバ初期化リストにないメンバ変数は、同じタイミングでデフォルト値で初期化される
メンバ初期化リストがなくても良いが、ある方がメリットが多いかも

```c++
Car::Car(){
    num = 0;
    gas = 0.0;
}
Car::Car(int n, double g){
    num = n;
    gas = g;
}

Car car1;               // num=0, gas=0.0
Car car2(1234, 20.5);   // num=1234, gas=20.5
Car cars[6];
```

コンストラクタ内で他のコンストラクタを呼び出す：

```c++
class クラス名 {
public:
    クラス名(型 仮引数名, 型 仮引数名, ...);
};

クラス名::クラス名(型 仮引数名, 型 仮引数名, ...) : クラス名(引数) {
    // ...
}
```

他のインスタンスをコピーするために、コピーコンストラクタを定義する

```c++
class クラス名 {
public:
    クラス名(const クラス名& 仮引数名);
};

クラス名::クラス名(const クラス名& 仮引数名) {
    // ...
}
```

`クラス名 変数 = 42`のように、int型引数が１つのコンストラクタを`=`で呼び出せる(暗黙のコンストラクタの呼び出し)
しかしこれが誤解させてしまう時があるので、暗黙のコンストラクタの呼び出しを禁止する方法がある
特に理由がなければ`explicit`を指定してしまえば良い

```c++
class クラス名 {
public:
    explicit クラス名(型 仮引数名, 型 仮引数名, ...);
};

クラス名::クラス名(型 仮引数名, 型 仮引数名, ...) : メンバ変数(初期値), .... {
    // ...
}
```

## デストラクタ

```c++
class クラス名 {
public:
    ~クラス名();
};

クラス名::~クラス名(){
    // ...
}
```
