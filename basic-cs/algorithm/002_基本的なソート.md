# 基本的なソートアルゴリズム

## ソート

ソート(整列、sorting)とは、レコードの集まりをキーの値の大小関係に従って並べ換える操作である。
- 昇順: キーが小さいものから大きなものへと、単調増加になるように並べる
- 降順: キーが大きなものから小さなものへと、単調減少になるように並べる

ソートアルゴリズムは、n個のレコードをソートするのに、==最小でもO(nlog n)の計算量が必要==となることが証明されている。

### 比較回数と交換回数

交換の対象となるデータが大きければ、計算量が同じアルゴリズムでも、交換の回数が少ないものを選ぶべきだ。  
逆に比較にコストがかかるならば、計算量が同じアルゴリズムでも、できるだけ比較の回数が少ないものを選ぶべきだ。

### 定数項部分

高速なアルゴリズムは技巧をこらして処理が複雑になる傾向があり、 単純なアルゴリズムに比べて計算量の定数項部分が大きくなる。  
そのため、対象となるレコード数があまり多くなければ、 高速なアルゴリズムよりも単純なアルゴリズムのほうが処理が速いことがある

### 安定なソート

同じキーのソート前の順序が、ソート後も同じになるようなソートアルゴリズムである。  
一方、安定でないアルゴリズムでは、ソート前の位置関係は保存ないが、常に位置関係が保たれないわけでもない。  
一般に、単純な(遅い)アルゴリズムは安定で、複雑な(高速な)アルゴリズムは安定でないという傾向がある(例外もある)。

### 内部ソートと外部ソート

- `内部ソート(internal sorting)`: ソートされるデータの格納領域(メモリ)上で並び替えを進めるソートアルゴリズム
- `外部ソート(external sorting)`: ソートされるデータの格納領域以外に同等以上の記憶領域を必要とするソートアルゴリズム  
    例: マージソート

## バブルソート(bubble sort)

右から左に向かって、隣り合う２つの数字を比較して入れ替える。  
計算量はO(n^2^)

## 選択ソート(selection sort)

数列の中から最小値を検索し、左端の数値と入れ替える。  
計算量はO(n^2^)

## 挿入ソート(insertion sort)

数列の左側から順番にソートしていくイメージ。  
一番左をソート済にして、未ソートの数字をソート済の数字と比べて位置を確定する。  
計算量はO(n^2^)

## ヒープソート

データ構造のヒープを利用したソート。  
ヒープが降順になるようにする(一番上が一番大きい)。

### 計算量

一番最初はデータをヒープに入れる必要がある。O(n回*log n)  
数字を取り出し、ヒープを再構築する。O(n回*log n)  
よって、全体の計算量はO(n log n)

## マージソート(merge sort)

「分割統治法」を利用したソートで、**ソートアルゴリズムの中でも最速の部類**  
ソートしたい数列を、ほぼ同じ長さの２つの数列に分割していく。  
各グループが１個の数字になったら、グループ同士を比較しながら統合していく。  
全体の計算量はO(n log n)
1. データ列を真ん中で2つの部分列a, bに分割する
2. 部分列a, bをそれぞれソートする
3. ソート済になった部分列a, bをマージする

## クイックソート(quick sort)

「分割統治法」を利用したソートで、**ソートアルゴリズムの中でも最速の部類**  
基準となる数(pivot)を数列の中からランダムに１つ選ぶ。  
ピボット以外の数を、「ピボットより小さい数」と「ピボットより大きい数」の２つのグループに分ける。  
各グループ内にまたクイックソートでソートする。

### 計算量

全体の計算量はO(n log n)  
ただし、毎回最小値/最大値をpivotとして選ぶと、O(n^2^)になる  
クイックソートが最も高速に実行されるのは、分割を行った結果、==ピボットの要素がちょうど真ん中に位置するような場合==である  
反対に、ピボットが端に来るような分割が続くと、クイックソートはかなり効率が悪くなる  
皮肉なことに、あらかじめ整列されている配列をソートさせると、クイックソートの効率は最悪となり、計算量はO(n^2^)になる

## ビンソート

==比較によらないソートアルゴリズムの１つである==  
ある範囲内に収まっている整数(例えば、0～100の整数)を整列することを考える  
整列の対象となる整数は重複していないものとする
1. データが取りうる値の種類の数と同数のビンを用意し、それぞれのビンにデータの値に対応する名前を付けておく
2. 整列対象となるデータを1つずつ順に、対応する名前のビンに入れていく
3. すべてのデータをビンに入れ終えた時点で、ビンの中身を順番に取り出して並べる

キーの範囲が広すぎる場合、ビンソートは実用的ではない  
ビンソートの領域計算量はO(n)とみなせる  
ビンソートは計算量がO(n)と高速である反面、データの量に比例する作業領域が必要となる  
時間と空間のトレードオフということができる  
キーの大小比較を利用するアルゴリズムの計算量の限界O(nlog n)を超える代償として、大きな作業領域が必要になるわけである  
ビンソートの2つの弱点:
1. キーの重複が許されない:  
    連結リストなどを使用し、ビンに複数のデータが入るようにすれば解決可能  
    なお、分布数え上げソートは、連結リストを使用せずに重複したキーをソート可能
2. キーはある範囲に収まる整数でなければならない(実用上、その範囲はかなり狭い必要有):  
    分布数え上げソートも同様の制約を受ける．基数ソートアルゴリズムでは、この制約を逃れることが可能

### 計算量

データの個数をn、用意したビンの個数をmとして、計算量はO(m+n) -> O(n)  
用意したビンの個数mがデータの個数nに比べて極端に大きい場合を除けば、  
ビンソートに必要な計算量はO(n)とみなすことができ、O(nlog n)の壁を越えられた。
