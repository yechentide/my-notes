# 基本的な探索アルゴリズム

## 探索(searching)

探索とは、n個のデータが登録されている表の中からある特定の値を持つデータを探し出す操作である。  
探索は、最も頻繁に利用されるアルゴリズムの1つである。  
表に格納する1つ1つのデータはレコード構造(record structure)となっている。  
このレコード構造は、1個以上のフィールド(field)を持っている。  
これらのフィールドのうち、ある特定のフィールドが探索の対象となる時、それをキー(key)と呼ぶ。  
探索は次の3つの機能から構成される:
1. 探索「与えられたキーをもつデータを表から探し出す」
2. 挿入「データを表に登録する」
3. 削除「データを表から取り除く」

## 線形探索(linear search)

配列の先頭から順番にデータを調べる方法。計算量はO(n)

## 2分探索(binary search)

配列は予めにソートされている必要がある。  
真ん中のデータと調べたいデータと比較して、真ん中のどの側にあるのかを確認できる。  
これを、目的データが見つかるか、存在しないとわかるまで繰り返す。  
計算量はO(log n)

## ハッシュ法(hashing)

ハッシュ法は、データの量にかかわらず挿入、探索、削除の操作を実質的にO(1)で行える優れたアルゴリズムである。  
キーの値をデータが格納される位置(配列の添え字の値)に関連づける。

### 原理

ハッシュ関数h(x)を使って、キーの値をもとにして、配列にデータを絡納できる。  
データを格納する配列をハッシュ表(hash table)と呼び、ハッシュ表の各要素をバケット(bucket)と呼ぶ。  
キーの値からハッシュ関数を用いてハッシュ値を求めて、ある特定のバケットに結びつけることによって、高速な探索を実現するのがハッシュ法である。  
計算量がO(1)のハッシュ関数を用いれば、挿入、探索、削除をO(1)で行うことができる。
> ハッシュ関数(hash function)
> キーを配列の添え字へと変換する関数。戻り値をハッシュ値(hash value)という。

### ハッシュ値の衝突(collision)

異なったキーに対して同じハッシュ値が得られることを衝突、またはシノニム(synonym)という。  
衝突が起きる場合、何らかの対策を施さなければハッシュ法は使いものにならない。  
==すべてのバケットにできるだけ均等に振り分ける==ようなハッシュ関数を選ばなければならない。  
バケットの数をB、登録するデータの数をN、各バケットには平均N/B個のデータが入ることとして、衝突対策を説明する。

### 衝突対策1: チェイン法

同じハッシュ値のデータを連結リストで繋ぐ方法である。  
計算量:   探索O(1+N/B)、  挿入O(1+N/B)、  削除O(1+N/B)  
データの個数Nに対してバケットの数Bが十分に大きければ、N/Bを定数と見なせるので、O(1+N/B) = O(1)  
データの個数Nに対してバケットの数Bが小さい場合、O(1+N/B) = O(N)

### 衝突対策2: オープンアドレス法

衝突が発生したときに、再ハッシュ(rehashing)で別のバケットにデータを格納する方法。  
もし、再ハッシュをB回(Bはバケットの個数)繰り返しても、空のバケットが見つからなければ、  
ハッシュ表が満杯なので、これ以上データを登録することができなくなる。  
==削除をする場合には、データを空にするのではなく、「削除済み」という状態を設定する。==  
そして、探索を行うときに、「削除済み」のバケットがあれば、探索を継続することになる。

### ハッシュ関数

ハッシュ法では、均等なハッシュ値を発生するハッシュ関数が求められる。  
ここでいう「均等」とは、全てのキー値を対象としたときに、ハッシュ値が等確率で生成される(静的均等)だけでは不十分である。  
実際の使用にあたっては、全てのキー値が等確率で出現するわけではなく、キー値はかなり偏っているのが一般的である。  
そのため、実際にキーとして使われる値に対して、ハッシュ値が均等に振り分けられる(動的均等)ことが望まれる。  
ハッシュ関数は、できるだけキーの全てのビットがハッシュ値に影響を与えるようにすべきである。  
「キーの値を二乗してその中央をとる(平方採中法、middle-suqare method)」という方法は、かなり良好な結果が得られることが知られている。

## 幅優先探索

グラフを探索するアルゴリズムの１つ。  
各ノードを探索する際、出発ノードに近いノードから探索していく。  
ゴールが始点の近くにある場合、探索が早く終了する。

## 深さ優先探索

グラフを探索するアルゴリズムの１つ。  
各ノードを探索する際、１つのルートをいけるところまで進んでいく。

## ベルマン・フォード法

辺重み付きグラフの最短経路問題を解くアルゴリズムの１つで、「動的計画法」を利用した。  
有向グラフでも無向グラフでも使える。コストが負の場合でも使えるが、最短経路が存在しないという判断になる。
1. 各ノードはコストを記録できる
2. 初期化: 始点を0、それ以外を無限にする
3. 辺を１つ選んで、両サイドのノードのコストを計算する
4. 全ての辺に対して、3を繰り返す

### 計算量

ノード数n、エッジ数mの場合、n巡*O(m)/巡なので、全体的にO(nm)となる。

## ダイクストラ法

辺重み付きグラフの最短経路問題を解くアルゴリズムの１つ。  
ただし、負のコストを含む場合、正しい答えが出ない。
1. 各ノードはコストを記録できる
2. 初期化: 始点を0、それ以外を無限にする
3. 現在のノードとつながるノードを候補に追加する
4. 候補ノードのコストを計算する
5. コストが一番小さいノードを、次のノードとする
6. 3~5を繰り返す

### 計算量

ノード数n、エッジ数mの場合、n巡*O(m)/巡なので、全体的にO(m + n log n)となる。

## A*(エー・スター)

ダイクストラ法を発展させたものとなる。  
予め推定コストをヒントとして設定し、無駄な探索を省くように改良した。  
その推定コストを「ヒューリスティックコスト」と呼ぶ。  
各地点において、ゴールまでのコストについて何らかのヒントを得られる場合に有用。  
逆に全く得られない場合は、A*を使えない。  
ヒューリスティックコストは、実際のコストと近いほど、探索の効率がよくなる。
