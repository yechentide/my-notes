# 探索木

## 二分探索木(binary tree)

木構造の１つで、各ノードは最大２つの子をもつ。  
二分探索木は二分木を元にして探索を行う方法である。  
二分探索木では、二分木の任意のノードxについて、  
左部分木に含まれる要素はノードxよりも小さく、右部分木に含まれる要素はノードxよりも大きくなるように、データをもたせる。
- 性質1: 全てのノードは、その左部分木に含まれるどの数よりも大きい
- 性質2: 全てのノードは、その右部分木に含まれるどの数よりも小さい

木の形のバランスが取れている場合、探索などの計算量はO(log n)だが、  
偏って一直線に並んだような形だと、O(n)になる。

### 探索

二分探索と同じ  
探索アルゴリズムの計算量は、探索が成功または失敗するまでに立ち寄ったノードの数で決まる  
つまり、==計算量は木の形(枝振り)によって決まる==

### 挿入

探索と同じ要領で木をたどり、たどるべき部分木がない時に、そこにデータを置けばよい

### 削除

要素の削除は、探索や挿入に比べると複雑になる。  
何も考えずにノードを削除すると、二分探索木の性質を満たさなくなる恐れがある。
- 子を持たないノードの削除:  
    最も簡単で、単にそのノードを削除すればよい
- 子を1つだけ持ったノードの削除:  
    削除されるノードがあった場所に、その子を移動させる
- 子を2つ持ったノードの削除:  
    削除するノードをその右部分木に含まれる最小の要素で置き換える

### 計算量

二分探索木の計算量を考えるとき、挿入も削除も、探索を行って挿入すべき位置あるいは削除する対象を決める。  
そのため、二分探索木の計算量は、探索の計算量に帰結する。  
上にあるように、==探索の計算量は木の枝振りによって大きく変わる==。  
直観的に、木が低くて枝分かれしている方が探索の計算量は少なくなりそうに思える。  
==完全二分木である二分探索木は、探索の効率が最もよくなる==。  
最良でO(log n)、最悪でO(n)になる。ノード数が大きいほどその差も大きくなる。

### 使う意義

ハッシュ法はO(1)で探索を行えるのに対して、単に探索を行うのであれば、二分探索木のメリットがほとんどない。  
しかし、二分探索木では要素の大小関係が保存されているので、最小値or最大値を探す・削除するといった操作を平均O(log n)で実行できる。  
これに対して、ハッシュ法では要素の大小関係が保存されていないので、全ての要素を調べなくてはならず、その計算量はO(n)となる。

## 平衡木(balanced tree)

二分探索木の最大の欠点は、平均的にはO(log n)でできる操作が、運が悪いとO(n)になってしまうという点である。  
この欠点を解消するには、挿入と削除を行う際に、木の形がなるべく完全二分木に近くなるように保てば良い。  
挿入と削除を行う度に、木の形を変形して、高さがlog~2~ n程度に収まるように工夫した木のこと平衡木という。  
木の形を見直すことがO(n)かかったとすると、計算量は結局O(n)となってしまうので、効率的なアルゴリズムが必要である。

### B木(B-tree)

B木は実用的なデータ構造の１つで、特に外部記憶上での探索に適している。  
B木はm分木をもとにしたデータ構造である。
> m分木
>> ノードが最大mm個(m≥2m≥2)の子を持つことができる木構造で、二分木を一般化したもの。  
>> 多分木(multi-way tree)と呼ぶこともある。また、このような探索木を多分探索木(multi-way search tree)という。

#### B木の条件

1. 根は、葉であるか、あるいは2～m個の子を持っている
2. 根と葉以外のノードは、(m/2)〜m個の子を持っている
3. 根から全ての葉までのパスの長さが等しい

二分探索木は全てのノードがデータ(要素)を持つのに対して、  
B木ではデータを持つのは葉のみで、内部ノードはキーだけを持つ構成が一般的である。  
n個の要素を持つB木の高さは、最悪のケースでlog~m/2~ nぐらい、最良のケースでlog~m~ nぐらいになる。  
全てのノードがm/2個しか子を持っていないのが最悪のケース、全てのノードがm個の子を持っているのが最良のケースとなる。  
いずれにしても、n個の要素を持つB木の高さはO(log n)に収まる。
