# 基本的なデータ構造

## リスト

データを一直線に並べた構造をしている。  
データの追加や削除がしやすい反面、アクセスには時間がかかる。
- 単方向リスト
- 双方向リスト
- 環状リスト

### 計算量

- アクセス: O(n)
- 追加: O(1)      追加したい箇所はわかってる場合
- 削除: O(1)      削除したい箇所はわかってる場合

## 配列

データを１列に並べるもの。  
データのアクセスは簡単に行えるが、追加や削除にはコストがかかる。

### 計算量

- アクセス: O(1)
- 追加: O(n)
- 削除: O(n)

## スタック

データを１列に並べ、一番新しいデータにしかアクセスできない。  
「後入れ先出し」なので、「LIFO」と略して呼ぶこともある。  
「深さ優先探索」で利用される。

### 計算量

- 要素の挿入: O(1)
- 要素の削除: O(1)

## キュー

データを１列に並べるが、追加する側と削除(アクセス)する側が反対である。  
「先入れ先出し」なので、「FIFO」と略して呼ぶこともある。  
「幅優先探索」で利用される。

### 計算量

- 要素の挿入: O(1)
- 要素の削除: O(1)

## ハッシュテーブル

「キー」と「値」のセットでデータを格納する。  
「辞書(Dictionary)」「連想配列」「Map」「Key-Value Store(KVS)」など、言語によって呼び方が違う。  
[ハッシュ関数](./004_基本的な探索アルゴリズム.md#ハッシュ法(hashing))を利用して、与えられたキーのハッシュ値を計算し、対応するデータの配列内の位置とする。  
ハッシュ値の衝突が起こり得るので、繰り返しハッシュ値を計算する方法もある(rehash)。
1. チェイン法
2. オープンアドレス法

## Set

セットは「要素の集合」を管理するものである
- 要素には順序がない
- 要素には重複がない

## ヒープ

グラフ木構造の１つで、「プライオリティキュー」を実現するときに使われる。  
> プライオリティキュー:  
> データを自由に追加でき、最小値から順に取り出せる。

木の形はノードの個数で決まる。  
データの追加において、追加されるノードは上に詰め、また同じ段では左に詰める。  
追加されるノードは、親ノードより小さければ、親子を入れ替える。  
データを削除するとき、まず一番右下のノードを一番上に持ってきて、その後大小比較して、  
子ノードのうち、小さい方と入れ替える。

### 計算量

- アクセス: O(1)
- 取り出し後の再構築: O(log n)
- 追加: O(log n)
